<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ext-php-rs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="getting-started/cargo-php.html"><strong aria-hidden="true">3.</strong> cargo php</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">4.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/numbers.html"><strong aria-hidden="true">4.1.</strong> Primitive Numbers</a></li><li class="chapter-item expanded "><a href="types/string.html"><strong aria-hidden="true">4.2.</strong> String</a></li><li class="chapter-item expanded "><a href="types/str.html"><strong aria-hidden="true">4.3.</strong> &str</a></li><li class="chapter-item expanded "><a href="types/bool.html"><strong aria-hidden="true">4.4.</strong> bool</a></li><li class="chapter-item expanded "><a href="types/vec.html"><strong aria-hidden="true">4.5.</strong> Vec</a></li><li class="chapter-item expanded "><a href="types/hashmap.html"><strong aria-hidden="true">4.6.</strong> HashMap</a></li><li class="chapter-item expanded "><a href="types/binary.html"><strong aria-hidden="true">4.7.</strong> Binary</a></li><li class="chapter-item expanded "><a href="types/binary_slice.html"><strong aria-hidden="true">4.8.</strong> BinarySlice</a></li><li class="chapter-item expanded "><a href="types/option.html"><strong aria-hidden="true">4.9.</strong> Option</a></li><li class="chapter-item expanded "><a href="types/object.html"><strong aria-hidden="true">4.10.</strong> Object</a></li><li class="chapter-item expanded "><a href="types/class_object.html"><strong aria-hidden="true">4.11.</strong> Class Object</a></li><li class="chapter-item expanded "><a href="types/closure.html"><strong aria-hidden="true">4.12.</strong> Closure</a></li><li class="chapter-item expanded "><a href="types/functions.html"><strong aria-hidden="true">4.13.</strong> Functions & methods</a></li><li class="chapter-item expanded "><a href="macros/async_impl.html"><strong aria-hidden="true">4.14.</strong> Async futures</a></li></ol></li><li class="chapter-item expanded "><a href="macros/index.html"><strong aria-hidden="true">5.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/module.html"><strong aria-hidden="true">5.1.</strong> Module</a></li><li class="chapter-item expanded "><a href="macros/module_startup.html"><strong aria-hidden="true">5.2.</strong> Module Startup Function</a></li><li class="chapter-item expanded "><a href="macros/function.html"><strong aria-hidden="true">5.3.</strong> Function</a></li><li class="chapter-item expanded "><a href="macros/classes.html"><strong aria-hidden="true">5.4.</strong> Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/impl.html"><strong aria-hidden="true">5.4.1.</strong> impls</a></li><li class="chapter-item expanded "><a href="macros/async_impl.html"><strong aria-hidden="true">5.4.2.</strong> async impls</a></li></ol></li><li class="chapter-item expanded "><a href="macros/constant.html"><strong aria-hidden="true">5.5.</strong> Constants</a></li><li class="chapter-item expanded "><a href="macros/zval_convert.html"><strong aria-hidden="true">5.6.</strong> ZvalConvert</a></li></ol></li><li class="chapter-item expanded "><a href="exceptions.html"><strong aria-hidden="true">6.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="ini-settings.html"><strong aria-hidden="true">7.</strong> INI Settings</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ext-php-rs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>ext-php-rs</code> is a Rust library containing bindings and abstractions for the PHP
extension API, which allows users to build extensions natively in Rust.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>Easy to use:</strong> The built-in macros can abstract away the need to interact
with the Zend API, such as Rust-type function parameter abstracting away
interacting with Zend values.</li>
<li><strong>Lightweight:</strong> You don't have to use the built-in helper macros. It's
possible to write your own glue code around your own functions.</li>
<li><strong>Extensible:</strong> Implement <code>IntoZval</code> and <code>FromZval</code> for your own custom types,
allowing the type to be used as function parameters and return types.</li>
</ul>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>Our main goal is to <strong>make extension development easier.</strong></p>
<ul>
<li>Writing extensions in C can be tedious, and with the Zend APIs limited
documentation can be intimidating.</li>
<li>Rust's modern language features and feature-full standard library are big
improvements on C.</li>
<li>Abstracting away the raw Zend APIs allows extensions to be developed faster
and with more confidence.</li>
<li>Abstractions also allow us to support future (and potentially past) versions
of PHP without significant changes to extension code.</li>
</ul>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p><code>ext-php-rs</code> follows semantic versioning, however, no backwards compatibility is
guaranteed while we are at major version <code>0</code>, which is for the foreseeable
future. It's recommended to lock the version at the patch level.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li>This guide!</li>
<li><a href="https://docs.rs/ext-php-rs">Rust docs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>To get started using <code>ext-php-rs</code> you will need both a Rust toolchain
and a PHP development environment. We'll cover each of these below.</p>
<h2 id="rust-toolchain"><a class="header" href="#rust-toolchain">Rust toolchain</a></h2>
<p>First, make sure you have rust installed on your system.
If you haven't already done so you can do so by following the instructions <a href="https://www.rust-lang.org/tools/install">here</a>.
<code>ext-php-rs</code> runs on both the stable and nightly versions so you can choose whichever one fits you best.</p>
<h2 id="php-development-environment"><a class="header" href="#php-development-environment">PHP development environment</a></h2>
<p>In order to develop PHP extensions, you'll need the following installed on your system:</p>
<ol>
<li>The PHP CLI executable itself</li>
<li>The PHP development headers</li>
<li>The <code>php-config</code> binary</li>
</ol>
<p>While the easiest way to get started is to use the packages provided by your distribution,
we recommend building PHP from source.</p>
<p><strong>NB:</strong> To use <code>ext-php-rs</code> you'll need at least PHP 8.0.</p>
<h3 id="using-a-package-manager"><a class="header" href="#using-a-package-manager">Using a package manager</a></h3>
<pre><code class="language-sh"># Debian and derivatives
apt install php-dev
# Arch Linux
pacman -S php
# Fedora
dnf install php-devel
# Homebrew
brew install php
</code></pre>
<h3 id="compiling-php-from-source"><a class="header" href="#compiling-php-from-source">Compiling PHP from source</a></h3>
<p>Please refer to this <a href="https://www.phpinternalsbook.com/php7/build_system/building_php.html">PHP internals book chapter</a>
for an in-depth guide on how to build PHP from source.</p>
<p><strong>TL;DR;</strong> use the following commands to build a minimal development version
with debug symbols enabled.</p>
<pre><code class="language-sh"># clone the php-src repository
git clone https://github.com/php/php-src.git
cd php-src
# by default you will be on the master branch, which is the current
# development version. You can check out a stable branch instead:
git checkout PHP-8.1
./buildconf
PREFIX="${HOME}/build/php"
./configure --prefix="${PREFIX}" \
    --enable-debug \
    --disable-all --disable-cgi
make -j "$(nproc)"
make install
</code></pre>
<p>The PHP CLI binary should now be located at <code>${PREFIX}/bin/php</code>
and the <code>php-config</code> binary at <code>${PREFIX}/bin/php-config</code>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>Now that we have our development environment in place,
let's go <a href="getting-started/./hello_world.html">build an extension</a> !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>We will start by creating a new Rust library crate:</p>
<pre><code class="language-sh">$ cargo new hello_world --lib
$ cd hello_world
</code></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml"><code>Cargo.toml</code></a></h3>
<p>Let's set up our crate by adding <code>ext-php-rs</code> as a dependency and setting the
crate type to <code>cdylib</code>. Update the <code>Cargo.toml</code> to look something like so:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
ext-php-rs = "*"

[profile.release]
strip = "debuginfo"
</code></pre>
<h3 id="cargoconfigtoml"><a class="header" href="#cargoconfigtoml"><code>.cargo/config.toml</code></a></h3>
<p>When compiling for Linux and macOS, we do not link directly to PHP, rather PHP
will dynamically load the library. We need to tell the linker it's ok to have
undefined symbols (as they will be resolved when loaded by PHP).</p>
<p>On Windows, we also need to switch to using the <code>rust-lld</code> linker.</p>
<blockquote>
<p>Microsoft Visual C++'s <code>link.exe</code> is supported, however you may run into
issues if your linker is not compatible with the linker used to compile PHP.</p>
</blockquote>
<p>We do this by creating a Cargo config file in <code>.cargo/config.toml</code> with the
following contents:</p>
<pre><code class="language-toml">[target.'cfg(not(target_os = "windows"))']
rustflags = ["-C", "link-arg=-Wl,-undefined,dynamic_lookup"]

[target.x86_64-pc-windows-msvc]
linker = "rust-lld"

[target.i686-pc-windows-msvc]
linker = "rust-lld"
</code></pre>
<h2 id="writing-our-extension"><a class="header" href="#writing-our-extension">Writing our extension</a></h2>
<h3 id="srclibrs"><a class="header" href="#srclibrs"><code>src/lib.rs</code></a></h3>
<p>Let's actually write the extension code now. We start by importing the
<code>ext-php-rs</code> prelude, which contains most of the imports required to make a
basic extension. We will then write our basic <code>hello_world</code> function, which will
take a string argument for the callers name, and we will return another string.
Finally, we write a <code>get_module</code> function which is used by PHP to find out about
your module. The <code>#[php_module]</code> attribute automatically registers your new
function so we don't need to do anything except return the <code>ModuleBuilder</code> that
we were given.</p>
<p>We also need to enable the <code>abi_vectorcall</code> feature when compiling for Windows.
This is a nightly-only feature so it is recommended to use the <code>#[cfg_attr]</code>
macro to not enable the feature on other operating systems.</p>
<pre><code class="language-rust ignore">#![cfg_attr(windows, feature(abi_vectorcall))]
use ext_php_rs::prelude::*;

#[php_function]
pub fn hello_world(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}

#[php_module]
pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
    module
}</code></pre>
<h2 id="building-the-extension"><a class="header" href="#building-the-extension">Building the extension</a></h2>
<p>Now let's build our extension.
This is done through <code>cargo</code> like any other Rust crate.</p>
<p>If you installed php using a package manager in the previous chapter
(or if the <code>php</code> and <code>php-config</code> binaries are already in your <code>$PATH</code>),
then you can just run</p>
<pre><code class="language-sh">cargo build
</code></pre>
<p>If you have multiple PHP versions in your PATH, or your installation
resides in a custom location, you can use the following environment variables:</p>
<pre><code class="language-sh"># explicitly specifies the path to the PHP executable:
export PHP=/path/to/php
# explicitly specifies the path to the php-config executable:
export PHP_CONFIG=/path/to/php-config
</code></pre>
<p>As an alternative, if you compiled PHP from source and installed it under
it's own prefix (<code>configure --prefix=/my/prefix</code>), you can just put
this prefix in front of your PATH:</p>
<pre><code class="language-sh">export PATH="/my/prefix:${PATH}"
</code></pre>
<p>Once you've setup these variables, you can just run</p>
<pre><code class="language-sh">cargo build
</code></pre>
<p>Cargo will track changes to these environment variables and rebuild the library accordingly.</p>
<h2 id="testing-our-extension"><a class="header" href="#testing-our-extension">Testing our extension</a></h2>
<p>The extension we just built is stored inside the cargo target directory:
<code>target/debug</code> if you did a debug build, <code>target/release</code> for release builds.</p>
<p>The extension file name is OS-dependent. The naming works as follows:</p>
<ul>
<li>let <code>S</code> be the empty string</li>
<li>append to <code>S</code> the value of <a href="https://doc.rust-lang.org/std/env/consts/constant.DLL_PREFIX.html">std::env::consts::DLL_PREFIX</a>
(empty on windows, <code>lib</code> on unixes)</li>
<li>append to <code>S</code> the lower-snake-case version of your crate name</li>
<li>append to <code>S</code> the value of <a href="https://doc.rust-lang.org/std/env/consts/constant.DLL_SUFFIX.html">std::env::consts::DLL_SUFFIX</a>
(<code>.dll</code> on windows, <code>.dylib</code> on macOS, <code>.so</code> on other unixes).</li>
<li>set the filename to the value of <code>S</code></li>
</ul>
<p>Which in our case would give us:</p>
<ul>
<li>linux: <code>libhello_world.so</code></li>
<li>macOS: <code>libhello_world.dylib</code></li>
<li>windows: <code>hello_world.dll</code></li>
</ul>
<p>Now we need a way to tell the PHP CLI binary to load our extension.
There are <a href="https://www.phpinternalsbook.com/php7/build_system/building_extensions.html#loading-shared-extensions">several ways to do that</a>.
For now we'll simply pass the <code>-d extension=/path/to/extension</code> option to the PHP CLI binary.</p>
<p>Let's make a test script:</p>
<h3 id="testphp"><a class="header" href="#testphp"><code>test.php</code></a></h3>
<pre><code class="language-php">&lt;?php

var_dump(hello_world("David"));
</code></pre>
<p>And run it:</p>
<pre><code class="language-sh">$ php -d extension=./target/debug/libhello_world.so test.php
string(13) "Hello, David!"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-php"><a class="header" href="#cargo-php"><code>cargo php</code></a></h1>
<p>ext-php-rs comes with a cargo subcommand called <a href="https://crates.io/crates/cargo-php"><code>cargo-php</code></a>. When called in
the manifest directory of an extension, it allows you to do the following:</p>
<ul>
<li>Generate IDE stub files</li>
<li>Install the extension</li>
<li>Remove the extension</li>
</ul>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<p>The subcommand has been tested on the following systems and architectures. Note
these are not requirements, but simply platforms that the application have been
tested on. YMMV.</p>
<ul>
<li>macOS 12.0 (AArch64, x86_64 builds but untested)</li>
<li>Linux 5.15.1 (AArch64, x86_64 builds but untested)</li>
</ul>
<p>Windows is not currently supported by <code>ext-php-rs</code>.</p>
<h3 id="macos-note"><a class="header" href="#macos-note">macOS Note</a></h3>
<p>When installing your extension multiple times without uninstalling on macOS, you
may run into PHP exiting with <code>SIGKILL</code>. You can see the exact cause of the exit
in Console, however, generally this is due to a invalid code signature.
Uninstalling the extension and then reinstalling generally fixes this problem.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>The subcommand is installed through composer like any other Rust CLI
application:</p>
<pre><code class="language-text">$ cargo install cargo-php
</code></pre>
<p>You can then call the application via <code>cargo php</code> (assuming the cargo
installation directory is in your PATH):</p>
<pre><code class="language-text">$ cargo php --help
cargo-php 0.1.0

David Cole &lt;david.cole1340@gmail.com&gt;

Installs extensions and generates stub files for PHP extensions generated with `ext-php-rs`.

USAGE:
    cargo-php &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help
            Print help information

    -V, --version
            Print version information

SUBCOMMANDS:
    help
            Print this message or the help of the given subcommand(s)
    install
            Installs the extension in the current PHP installation
    remove
            Removes the extension in the current PHP installation
    stubs
            Generates stub PHP files for the extension
</code></pre>
<p>The command should always be executed from within your extensions manifest
directory (the directory with your <code>Cargo.toml</code>).</p>
<h2 id="stubs"><a class="header" href="#stubs">Stubs</a></h2>
<p>Stub files are used by your IDEs language server to know the signature of
methods, classes and constants in your PHP extension, similar to how a C header
file works.</p>
<p>One of the largest collection of PHP standard library and non-standard extension
stub files is provided by JetBrains: <a href="https://github.com/JetBrains/phpstorm-stubs#readme">phpstorm-stubs</a>. This collection is used
by JetBrains PhpStorm and the PHP Intelephense language server (which I
personally recommend for use in Visual Studio Code).</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-text">$ cargo php stubs --help
cargo-php-stubs

Generates stub PHP files for the extension.

These stub files can be used in IDEs to provide typehinting for extension classes, functions and
constants.

USAGE:
    cargo-php stubs [OPTIONS] [EXT]

ARGS:
    &lt;EXT&gt;
            Path to extension to generate stubs for. Defaults for searching the directory the
            executable is located in

OPTIONS:
    -h, --help
            Print help information

        --manifest &lt;MANIFEST&gt;
            Path to the Cargo manifest of the extension. Defaults to the manifest in the directory
            the command is called.

            This cannot be provided alongside the `ext` option, as that option provides a direct
            path to the extension shared library.

    -o, --out &lt;OUT&gt;
            Path used to store generated stub file. Defaults to writing to `&lt;ext-name&gt;.stubs.php` in
            the current directory

        --stdout
            Print stubs to stdout rather than write to file. Cannot be used with `out`
</code></pre>
<h2 id="extension-installation"><a class="header" href="#extension-installation">Extension Installation</a></h2>
<p>When PHP is in your PATH, the application can automatically build and copy your
extension into PHP. This requires <code>php-config</code> to be installed alongside PHP.</p>
<p>It is recommended to backup your <code>php.ini</code> <strong>before</strong> installing the extension
so you are able to restore if you run into any issues.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-text">$ cargo php install --help
cargo-php-install

Installs the extension in the current PHP installation.

This copies the extension to the PHP installation and adds the extension to a PHP configuration
file.

Note that this uses the `php-config` executable installed alongside PHP to locate your `php.ini`
file and extension directory. If you want to use a different `php-config`, the application will read
the `PHP_CONFIG` variable (if it is set), and will use this as the path to the executable instead.

USAGE:
    cargo-php install [OPTIONS]

OPTIONS:
        --disable
            Installs the extension but doesn't enable the extension in the `php.ini` file

    -h, --help
            Print help information

        --ini-path &lt;INI_PATH&gt;
            Path to the `php.ini` file to update with the new extension

        --install-dir &lt;INSTALL_DIR&gt;
            Changes the path that the extension is copied to. This will not activate the extension
            unless `ini_path` is also passed

        --manifest &lt;MANIFEST&gt;
            Path to the Cargo manifest of the extension. Defaults to the manifest in the directory
            the command is called

        --release
            Whether to install the release version of the extension

        --yes
            Bypasses the confirmation prompt
</code></pre>
<h2 id="extension-removal"><a class="header" href="#extension-removal">Extension Removal</a></h2>
<p>Removes the extension from your PHPs extension directory, and removes the entry
from your <code>php.ini</code> if present.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<pre><code class="language-text">$ cargo php remove --help
cargo-php-remove

Removes the extension in the current PHP installation.

This deletes the extension from the PHP installation and also removes it from the main PHP
configuration file.

Note that this uses the `php-config` executable installed alongside PHP to locate your `php.ini`
file and extension directory. If you want to use a different `php-config`, the application will read
the `PHP_CONFIG` variable (if it is set), and will use this as the path to the executable instead.

USAGE:
    cargo-php remove [OPTIONS]

OPTIONS:
    -h, --help
            Print help information

        --ini-path &lt;INI_PATH&gt;
            Path to the `php.ini` file to remove the extension from

        --install-dir &lt;INSTALL_DIR&gt;
            Changes the path that the extension will be removed from. This will not remove the
            extension from a configuration file unless `ini_path` is also passed

        --manifest &lt;MANIFEST&gt;
            Path to the Cargo manifest of the extension. Defaults to the manifest in the directory
            the command is called

        --yes
            Bypasses the confirmation prompt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>In PHP, data is stored in containers called zvals (zend values). Internally,
these are effectively tagged unions (enums in Rust) without the safety that Rust
introduces. Passing data between Rust and PHP requires the data to become a
zval. This is done through two traits: <code>FromZval</code> and <code>IntoZval</code>. These traits
have been implemented on most regular Rust types:</p>
<ul>
<li>Primitive integers (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>,
<code>usize</code>, <code>isize</code>).</li>
<li>Double and single-precision floating point numbers (<code>f32</code>, <code>f64</code>).</li>
<li>Booleans.</li>
<li>Strings (<code>String</code> and <code>&amp;str</code>)</li>
<li><code>Vec&lt;T&gt;</code> where T implements <code>IntoZval</code> and/or <code>FromZval</code>.</li>
<li><code>HashMap&lt;String, T&gt;</code> where T implements <code>IntoZval</code> and/or <code>FromZval</code>.</li>
<li><code>Binary&lt;T&gt;</code> where T implements <code>Pack</code>, used for transferring binary string
data.</li>
<li><code>BinarySlice&lt;T&gt;</code> where T implements <code>Pack</code>, used for exposing PHP binary
strings as read-only slices.</li>
<li>A PHP callable closure or function wrapped with <code>Callable</code>.</li>
<li><code>Option&lt;T&gt;</code> where T implements <code>IntoZval</code> and/or <code>FromZval</code>, and where <code>None</code>
is converted to a PHP <code>null</code>.</li>
</ul>
<p>Return types can also include:</p>
<ul>
<li>Any class type which implements <code>RegisteredClass</code> (i.e. any struct you have
registered with PHP).</li>
<li>An immutable reference to <code>self</code> when used in a method, through the <code>ClassRef</code>
type.</li>
<li>A Rust closure wrapped with <code>Closure</code>.</li>
<li><code>Result&lt;T, E&gt;</code>, where <code>T: IntoZval</code> and <code>E: Into&lt;PhpException&gt;</code>. When the
error variant is encountered, it is converted into a <code>PhpException</code> and thrown
as an exception.</li>
</ul>
<p>For a type to be returnable, it must implement <code>IntoZval</code>, while for it to be
valid as a parameter, it must implement <code>FromZval</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-numbers"><a class="header" href="#primitive-numbers">Primitive Numbers</a></h1>
<p>Primitive integers include <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>,
<code>isize</code>, <code>usize</code>, <code>f32</code> and <code>f64</code>.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td><code>i32</code> on 32-bit platforms, <code>i64</code> on 64-bit platforms, <code>f64</code> platform-independent</td></tr>
</tbody></table>
</div>
<p>Note that internally, PHP treats <strong>all</strong> of these integers the same (a 'long'),
and therefore it must be converted into a long to be stored inside the zval. A
long is always signed, and the size will be 32-bits on 32-bit platforms and
64-bits on 64-bit platforms.</p>
<p>Floating point numbers are always stored in a <code>double</code> type (<code>f64</code>), regardless
of platform. Note that converting a zval into a <code>f32</code> will lose accuracy.</p>
<p>This means that converting <code>i64</code>, <code>u32</code>, <code>u64</code>, <code>isize</code> and <code>usize</code> <em>can</em> fail
depending on the value and the platform, which is why all zval conversions are
fallible.</p>
<h2 id="rust-example"><a class="header" href="#rust-example">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn test_numbers(a: i32, b: u32, c: f32) -&gt; u8 {
    println!("a {} b {} c {}", a, b, c);
    0
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example"><a class="header" href="#php-example">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

test_numbers(5, 10, 12.5); // a 5 b 10 c 12.5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string"><code>String</code></a></h1>
<p>When a <code>String</code> type is encountered, the zend string content is copied to/from a
Rust <code>String</code> object. If the zval does not contain a string, it will attempt to
read a <code>double</code> from the zval and convert it into a <code>String</code> object.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td><code>zend_string</code> (C-string)</td></tr>
</tbody></table>
</div>
<p>Internally, PHP stores strings in <code>zend_string</code> objects, which is a refcounted C
struct containing the string length with the content of the string appended to
the end of the struct based on how long the string is. Since the string is
NUL-terminated, you cannot have any NUL bytes in your string, and an error will
be thrown if one is encountered while converting a <code>String</code> to a zval.</p>
<h2 id="rust-example-1"><a class="header" href="#rust-example-1">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn str_example(input: String) -&gt; String {
    format!("Hello {}", input)
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example-1"><a class="header" href="#php-example-1">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(str_example("World")); // string(11) "Hello World"
var_dump(str_example(5)); // string(7) "Hello 5"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="str"><a class="header" href="#str"><code>&amp;str</code></a></h1>
<p>A borrowed string. When this type is encountered, you are given a reference to
the actual zend string memory, rather than copying the contents like if you were
taking an owned <code>String</code> argument.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>No</td><td>Yes</td><td>No</td><td>Yes</td><td><code>zend_string</code> (C-string)</td></tr>
</tbody></table>
</div>
<p>Note that you cannot expect the function to operate the same by swapping out
<code>String</code> and <code>&amp;str</code> - since the zend string memory is read directly, this
library does not attempt to parse <code>double</code> types as strings.</p>
<p>See the <a href="types/./string.html"><code>String</code></a> for a deeper dive into the internal structure of
PHP strings.</p>
<h2 id="rust-example-2"><a class="header" href="#rust-example-2">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn str_example(input: &amp;str) -&gt; String {
    format!("Hello {}", input)
}

#[php_function]
pub fn str_return_example() -&gt; &amp;'static str {
    "Hello from Rust"
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example-2"><a class="header" href="#php-example-2">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(str_example("World")); // string(11) "Hello World"
var_dump(str_example(5)); // Invalid

var_dump(str_return_example());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool"><code>bool</code></a></h1>
<p>A boolean. Not much else to say here.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>Union flag</td></tr>
</tbody></table>
</div>
<p>Booleans are not actually stored inside the zval. Instead, they are treated as
two different union types (the zval can be in a true or false state). An
equivalent structure in Rust would look like:</p>
<pre><code class="language-rs">enum Zval {
    True,
    False,
    String(&amp;mut ZendString),
    Long(i64),
    // ...
}
</code></pre>
<h2 id="rust-example-3"><a class="header" href="#rust-example-3">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn test_bool(input: bool) -&gt; String {
    if input {
        "Yes!".into()
    } else {
        "No!".into()
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example-3"><a class="header" href="#php-example-3">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(test_bool(true)); // string(4) "Yes!"
var_dump(test_bool(false)); // string(3) "No!"
</code></pre>
<h2 id="rust-example-taking-by-reference"><a class="header" href="#rust-example-taking-by-reference">Rust example, taking by reference</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span><span class="boring">use ext_php_rs::types;
</span>#[php_function]
pub fn test_bool(input: &amp;mut types::Zval) {
    input.reference_mut().unwrap().set_bool(false);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec"><code>Vec</code></a></h1>
<p>Vectors can contain any type that can be represented as a zval. Note that the
data contained in the array will be copied into Rust types and stored inside the
vector. The internal representation of a PHP array is discussed below.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td><code>ZendHashTable</code></td></tr>
</tbody></table>
</div>
<p>Internally, PHP arrays are hash tables where the key can be an unsigned long or
a string. Zvals are contained inside arrays therefore the data does not have to
contain only one type.</p>
<p>When converting into a vector, all values are converted from zvals into the
given generic type. If any of the conversions fail, the whole conversion will
fail.</p>
<h2 id="rust-example-4"><a class="header" href="#rust-example-4">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn test_vec(vec: Vec&lt;String&gt;) -&gt; String {
    vec.join(" ")
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example-4"><a class="header" href="#php-example-4">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(test_vec(['hello', 'world', 5])); // string(13) "hello world 5"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap"><code>HashMap</code></a></h1>
<p><code>HashMap</code>s are represented as associative arrays in PHP.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td><code>ZendHashTable</code></td></tr>
</tbody></table>
</div>
<p>Converting from a zval to a <code>HashMap</code> is valid when the key is a <code>String</code>, and
the value implements <code>FromZval</code>. The key and values are copied into Rust types
before being inserted into the <code>HashMap</code>. If one of the key-value pairs has a
numeric key, the key is represented as a string before being inserted.</p>
<p>Converting from a <code>HashMap</code> to a zval is valid when the key implements
<code>AsRef&lt;str&gt;</code>, and the value implements <code>IntoZval</code>.</p>
<h2 id="rust-example-5"><a class="header" href="#rust-example-5">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span><span class="boring">use std::collections::HashMap;
</span>#[php_function]
pub fn test_hashmap(hm: HashMap&lt;String, String&gt;) -&gt; Vec&lt;String&gt; {
    for (k, v) in hm.iter() {
        println!("k: {} v: {}", k, v);
    }

    hm.into_iter()
        .map(|(_, v)| v)
        .collect::&lt;Vec&lt;_&gt;&gt;()
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example-5"><a class="header" href="#php-example-5">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(test_hashmap([
    'hello' =&gt; 'world',
    'rust' =&gt; 'php',
    'okk',
]));
</code></pre>
<p>Output:</p>
<pre><code class="language-text">k: hello v: world
k: rust v: php
k: 0 v: okk
array(3) {
    [0] =&gt; string(5) "world",
    [1] =&gt; string(3) "php",
    [2] =&gt; string(3) "okk"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary"><a class="header" href="#binary"><code>Binary</code></a></h1>
<p>Binary data is represented as a string in PHP. The most common source of this
data is from the <a href="https://www.php.net/manual/en/function.pack.php"><code>pack</code></a> and <a href="https://www.php.net/manual/en/function.unpack.php"><code>unpack</code></a> functions. It allows you to transfer
arbitrary binary data between Rust and PHP.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td><code>zend_string</code></td></tr>
</tbody></table>
</div>
<p>The binary type is represented as a string in PHP. Although not encoded, the
data is converted into an array and then the pointer to the data is set as the
string pointer, with the length of the array being the length of the string.</p>
<p><code>Binary&lt;T&gt;</code> is valid when <code>T</code> implements <code>Pack</code>. This is currently implemented
on most primitive numbers (i8, i16, i32, i64, u8, u16, u32, u64, isize, usize,
f32, f64).</p>
<h2 id="rust-usage"><a class="header" href="#rust-usage">Rust Usage</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;
use ext_php_rs::binary::Binary;

#[php_function]
pub fn test_binary(input: Binary&lt;u32&gt;) -&gt; Binary&lt;u32&gt; {
    for i in input.iter() {
        println!("{}", i);
    }

    vec![5, 4, 3, 2, 1]
        .into_iter()
        .collect::&lt;Binary&lt;_&gt;&gt;()
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-usage"><a class="header" href="#php-usage">PHP Usage</a></h2>
<pre><code class="language-php">&lt;?php

$data = pack('L*', 1, 2, 3, 4, 5);
$output = unpack('L*', test_binary($data));
var_dump($output); // array(5) { [0] =&gt; 5, [1] =&gt; 4, [2] =&gt; 3, [3] =&gt; 2, [4] =&gt; 1 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-slices"><a class="header" href="#binary-slices"><code>Binary Slices</code></a></h1>
<p>Binary data is represented as a string in PHP. The most common source of this
data is from the <a href="https://www.php.net/manual/en/function.pack.php"><code>pack</code></a> and <a href="https://www.php.net/manual/en/function.unpack.php"><code>unpack</code></a> functions. It allows you to use a PHP
string as a read-only slice in Rust.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>No</td><td>No</td><td><code>zend_string</code></td></tr>
</tbody></table>
</div>
<p>The binary type is represented as a string in PHP. Although not encoded, the
data is converted into a slice and then the pointer to the data is set as the
string pointer, with the length of the array being the length of the string.</p>
<p><code>BinarySlice&lt;T&gt;</code> is valid when <code>T</code> implements <code>PackSlice</code>. This is currently
implemented on most primitive numbers (i8, i16, i32, i64, u8, u16, u32, u64,
isize, usize, f32, f64).</p>
<h2 id="rust-usage-1"><a class="header" href="#rust-usage-1">Rust Usage</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;
use ext_php_rs::binary_slice::BinarySlice;

#[php_function]
pub fn test_binary_slice(input: BinarySlice&lt;u8&gt;) -&gt; u8 {
    let mut sum = 0;
    for i in input.iter() {
        sum += i;
    }

    sum
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-usage-1"><a class="header" href="#php-usage-1">PHP Usage</a></h2>
<pre><code class="language-php">&lt;?php

$data = pack('C*', 1, 2, 3, 4, 5);
$output = test_binary_slice($data);
var_dump($output); // 15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optiont"><a class="header" href="#optiont"><code>Option&lt;T&gt;</code></a></h1>
<p>Options are used for optional and nullable parameters, as well as null returns.
It is valid to be converted to/from a zval as long as the underlying <code>T</code> generic
is also able to be converted to/from a zval.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>Depends on <code>T</code>, <code>null</code> for <code>None</code>.</td></tr>
</tbody></table>
</div>
<p>Using <code>Option&lt;T&gt;</code> as a parameter indicates that the parameter is nullable. If
null is passed, a <code>None</code> value will be supplied. It is also used in the place of
optional parameters. If the parameter is not given, a <code>None</code> value will also be
supplied.</p>
<p>Returning <code>Option&lt;T&gt;</code> is a nullable return type. Returning <code>None</code> will return
null to PHP.</p>
<h2 id="rust-example-6"><a class="header" href="#rust-example-6">Rust example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn test_option_null(input: Option&lt;String&gt;) -&gt; Option&lt;String&gt; {
    input.map(|input| format!("Hello {}", input).into())
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-example-6"><a class="header" href="#php-example-6">PHP example</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(test_option_null("World")); // string(11) "Hello World"
var_dump(test_option_null()); // null
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<p>An object is any object type in PHP. This can include a PHP class and PHP
<code>stdClass</code>. A Rust struct registered as a PHP class is a <a href="types/./class_object.html">class object</a>, which
contains an object.</p>
<p>Objects are valid as parameters but only as an immutable or mutable reference.
You cannot take ownership of an object as objects are reference counted, and
multiple zvals can point to the same object. You can return a boxed owned
object.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>No</td><td>Yes</td><td><code>ZBox&lt;ZendObject&gt;</code></td><td>Yes, mutable only</td><td>Zend object.</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="calling-a-method"><a class="header" href="#calling-a-method">Calling a method</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::{prelude::*, types::ZendObject};

// Take an object reference and also return it.
#[php_function]
pub fn take_obj(obj: &amp;mut ZendObject) -&gt; () {
    let _ = obj.try_call_method("hello", vec![&amp;"arg1", &amp;"arg2"]);
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="taking-an-object-reference"><a class="header" href="#taking-an-object-reference">Taking an object reference</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::{prelude::*, types::ZendObject};

// Take an object reference and also return it.
#[php_function]
pub fn take_obj(obj: &amp;mut ZendObject) -&gt; &amp;mut ZendObject {
    let _ = obj.set_property("hello", 5);
    dbg!(obj)
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="creating-a-new-object"><a class="header" href="#creating-a-new-object">Creating a new object</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::{prelude::*, types::ZendObject, boxed::ZBox};

// Create a new `stdClass` and return it.
#[php_function]
pub fn make_object() -&gt; ZBox&lt;ZendObject&gt; {
    let mut obj = ZendObject::new_stdclass();
    let _ = obj.set_property("hello", 5);
    obj
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-object"><a class="header" href="#class-object">Class Object</a></h1>
<p>A class object is an instance of a Rust struct (which has been registered as a
PHP class) that has been allocated alongside an object. You can think of a class
object as a superset of an object, as a class object contains a Zend object.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td>No</td><td><code>&amp;ZendClassObject&lt;T&gt;</code></td><td>Yes</td><td><code>&amp;mut ZendClassObject&lt;T&gt;</code></td><td>Zend object and a Rust struct.</td></tr>
</tbody></table>
</div>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="returning-a-reference-to-self"><a class="header" href="#returning-a-reference-to-self">Returning a reference to <code>self</code></a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::{prelude::*, types::ZendClassObject};

#[php_class]
pub struct Example {
    foo: i32,
    bar: i32
}

#[php_impl]
impl Example {
    // Even though this function doesn't have a `self` type, it is still treated as an associated method
    // and not a static method.
    pub fn builder_pattern(#[this] this: &amp;mut ZendClassObject&lt;Example&gt;) -&gt; &amp;mut ZendClassObject&lt;Example&gt; {
        // do something with `this`
        this
    }
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="creating-a-new-class-instance"><a class="header" href="#creating-a-new-class-instance">Creating a new class instance</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

#[php_class]
pub struct Example {
    foo: i32,
    bar: i32
}

#[php_impl]
impl Example {
    pub fn make_new(foo: i32, bar: i32) -&gt; Example {
        Example { foo, bar }
    }
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>Rust closures can be passed to PHP through a wrapper class <code>PhpClosure</code>. The
Rust closure must be static (i.e. can only reference things with a <code>'static</code>
lifetime, so not <code>self</code> in methods), and can take up to 8 parameters, all of
which must implement <code>FromZval</code>. The return type must implement <code>IntoZval</code>.</p>
<p>Passing closures from Rust to PHP is feature-gated behind the <code>closure</code> feature.
Enable it in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">ext-php-rs = { version = "...", features = ["closure"] }
</code></pre>
<p>PHP callables (which includes closures) can be passed to Rust through the
<code>Callable</code> type. When calling a callable, you must provide it with a <code>Vec</code> of
arguments, all of which must implement <code>IntoZval</code> and <code>Clone</code>.</p>
<div class="table-wrapper"><table><thead><tr><th><code>T</code> parameter</th><th><code>&amp;T</code> parameter</th><th><code>T</code> Return type</th><th><code>&amp;T</code> Return type</th><th>PHP representation</th></tr></thead><tbody>
<tr><td><code>Callable</code></td><td>No</td><td><code>Closure</code>, <code>Callable</code>for PHP functions</td><td>No</td><td>Callables are implemented in PHP, closures are represented as an instance of <code>PhpClosure</code>.</td></tr>
</tbody></table>
</div>
<p>Internally, when you enable the <code>closure</code> feature, a class <code>PhpClosure</code> is
registered alongside your other classes:</p>
<pre><code class="language-php">&lt;?php

class PhpClosure
{
    public function __invoke(..$args): mixed;
}
</code></pre>
<p>This class cannot be instantiated from PHP. When the class is invoked, the
underlying Rust closure is called. There are three types of closures in Rust:</p>
<h2 id="fn-and-fnmut"><a class="header" href="#fn-and-fnmut"><code>Fn</code> and <code>FnMut</code></a></h2>
<p>These closures can be called multiple times. <code>FnMut</code> differs from <code>Fn</code> in the
fact that it can modify variables in its scope.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

#[php_function]
pub fn closure_get_string() -&gt; Closure {
    // Return a closure which takes two integers and returns a string
    Closure::wrap(Box::new(|a, b| {
        format!("A: {} B: {}", a, b)
    }) as Box&lt;dyn Fn(i32, i32) -&gt; String&gt;)
}

#[php_function]
pub fn closure_count() -&gt; Closure {
    let mut count = 0i32;

    // Return a closure which takes an integer, adds it to a persistent integer,
    // and returns the updated value.
    Closure::wrap(Box::new(move |a: i32| {
        count += a;
        count
    }) as Box&lt;dyn FnMut(i32) -&gt; i32&gt;)
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="fnonce"><a class="header" href="#fnonce"><code>FnOnce</code></a></h2>
<p>Closures that implement <code>FnOnce</code> can only be called once. They consume some sort
of value. Calling these closures more than once will cause them to throw an
exception. They must be wrapped using the <code>wrap_once</code> function instead of
<code>wrap</code>.</p>
<p>Internally, the <code>FnOnce</code> closure is wrapped again by an <code>FnMut</code> closure, which
owns the <code>FnOnce</code> closure until it is called. If the <code>FnMut</code> closure is called
again, the <code>FnOnce</code> closure would have already been consumed, and an exception
will be thrown.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

#[php_function]
pub fn closure_return_string() -&gt; Closure {
    let example: String = "Hello, world!".into();

    // This closure consumes `example` and therefore cannot be called more than once.
    Closure::wrap_once(Box::new(move || {
        example
    }) as Box&lt;dyn FnOnce() -&gt; String&gt;)
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Closures must be boxed as PHP classes cannot support generics, therefore trait
objects must be used. These must be boxed to have a compile time size.</p>
<h2 id="callable"><a class="header" href="#callable"><code>Callable</code></a></h2>
<p>Callables are simply represented as zvals. You can attempt to get a callable
function by its name, or as a parameter. They can be called through the
<code>try_call</code> method implemented on <code>Callable</code>, which returns a zval in a result.</p>
<h3 id="callable-parameter"><a class="header" href="#callable-parameter">Callable parameter</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

#[php_function]
pub fn callable_parameter(call: ZendCallable) {
    let val = call.try_call(vec![&amp;0, &amp;1, &amp;"Hello"]).expect("Failed to call function");
    dbg!(val);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions--methods"><a class="header" href="#functions--methods">Functions &amp; methods</a></h1>
<p>PHP functions and methods are represented by the <code>Function</code> struct.</p>
<p>You can use the <code>try_from_function</code> and <code>try_from_method</code> methods to obtain a Function struct corresponding to the passed function or static method name.<br />
It's heavily recommended you reuse returned <code>Function</code> objects, to avoid the overhead of looking up the function/method name.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

use ext_php_rs::zend::Function;

#[php_function]
pub fn test_function() -&gt; () {
    let var_dump = Function::try_from_function("var_dump").unwrap();
    let _ = var_dump.try_call(vec![&amp;"abc"]);
}

#[php_function]
pub fn test_method() -&gt; () {
    let f = Function::try_from_method("ClassName", "staticMethod").unwrap();
    let _ = f.try_call(vec![&amp;"abc"]);
}

<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_async_impl"><a class="header" href="#php_async_impl"><code>#[php_async_impl]</code></a></h1>
<p>Using <code>#[php_async_impl]</code> instead of <code>#[php_impl]</code> allows us to expose any async Rust library to PHP, using <a href="https://www.php.net/manual/en/language.fibers.php">PHP fibers</a>, <a href="https://github.com/danog/php-tokio">php-tokio</a> and the <a href="https://revolt.run">PHP Revolt event loop</a> under the hood to handle async interoperability.</p>
<p>This allows full compatibility with <a href="https://amphp.org">amphp</a>, <a href="https://github.com/azjezz/psl">PSL</a>, <a href="https://reactphp.org">reactphp</a> and any other async PHP library based on <a href="https://revolt.run">Revolt</a>.</p>
<p>Traits annotated with <code>#[php_async_impl]</code> can freely expose any async function, using <code>await</code> and any async Rust library.</p>
<p>Make sure to also expose the <code>php_tokio::EventLoop::init</code> and <code>php_tokio::EventLoop::wakeup</code> functions to PHP in order to initialize the event loop, as specified in the full example <a href="macros/async_impl.html#async-example">here »</a>.</p>
<p>Also, make sure to invoke <code>EventLoop::shutdown</code> in the request shutdown handler to clean up the tokio event loop before finishing the request.</p>
<h2 id="async-example"><a class="header" href="#async-example">Async example</a></h2>
<p>In this example, we're exposing an async Rust HTTP client library called <a href="https://docs.rs/reqwest/latest/reqwest/">reqwest</a> to PHP, using <a href="https://www.php.net/manual/en/language.fibers.php">PHP fibers</a>, <a href="https://github.com/danog/php-tokio">php-tokio</a> and the <a href="https://revolt.run">PHP Revolt event loop</a> under the hood to handle async interoperability.</p>
<p>This allows full compatibility with <a href="https://amphp.org">amphp</a>, <a href="https://github.com/azjezz/psl">PSL</a>, <a href="https://reactphp.org">reactphp</a> and any other async PHP library based on <a href="https://revolt.run">Revolt</a>.</p>
<p>Make sure to require <a href="https://github.com/danog/php-tokio">php-tokio</a> as a dependency before proceeding.</p>
<pre><code class="language-rust ignore">use ext_php_rs::prelude::*;
use php_tokio::{php_async_impl, EventLoop};

#[php_class]
struct Client {}

#[php_async_impl]
impl Client {
    pub fn init() -&gt; PhpResult&lt;u64&gt; {
        EventLoop::init()
    }
    pub fn wakeup() -&gt; PhpResult&lt;()&gt; {
        EventLoop::wakeup()
    }
    pub async fn get(url: &amp;str) -&gt; anyhow::Result&lt;String&gt; {
        Ok(reqwest::get(url).await?.text().await?)
    }
}

pub extern "C" fn request_shutdown(_type: i32, _module_number: i32) -&gt; i32 {
    EventLoop::shutdown();
    0
}

#[php_module]
pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
    module.request_shutdown_function(request_shutdown)
}</code></pre>
<p>Here's the async PHP code we use to interact with the Rust class we just exposed.</p>
<p>The <code>Client::init</code> method needs to be called only once in order to initialize the Revolt event loop and link it to the Tokio event loop, as shown by the following code.</p>
<p>See <a href="https://amphp.org">here »</a> for more info on async PHP using <a href="https://amphp.org">amphp</a> + <a href="https://revolt.run">revolt</a>.</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);

namespace Reqwest;

use Revolt\EventLoop;

use function Amp\async;
use function Amp\Future\await;

final class Client
{
    private static ?string $id = null;

    public static function init(): void
    {
        if (self::$id !== null) {
            return;
        }

        $f = \fopen("php://fd/".\Client::init(), 'r+');
        \stream_set_blocking($f, false);
        self::$id = EventLoop::onReadable($f, fn () =&gt; \Client::wakeup());
    }

    public static function reference(): void
    {
        EventLoop::reference(self::$id);
    }
    public static function unreference(): void
    {
        EventLoop::unreference(self::$id);
    }

    public static function __callStatic(string $name, array $args): mixed
    {
        return \Client::$name(...$args);
    }
}


Client::init();

function test(int $delay): void
{
    $url = "https://httpbin.org/delay/$delay";
    $t = time();
    echo "Making async reqwest to $url that will return after $delay seconds...".PHP_EOL;
    Client::get($url);
    $t = time() - $t;
    echo "Got response from $url after ~".$t." seconds!".PHP_EOL;
};

$futures = [];
$futures []= async(test(...), 5);
$futures []= async(test(...), 5);
$futures []= async(test(...), 5);

await($futures);
</code></pre>
<p>Result:</p>
<pre><code>Making async reqwest to https://httpbin.org/delay/5 that will return after 5 seconds...
Making async reqwest to https://httpbin.org/delay/5 that will return after 5 seconds...
Making async reqwest to https://httpbin.org/delay/5 that will return after 5 seconds...
Got response from https://httpbin.org/delay/5 after ~5 seconds!
Got response from https://httpbin.org/delay/5 after ~5 seconds!
Got response from https://httpbin.org/delay/5 after ~5 seconds!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p><code>ext-php-rs</code> comes with a set of macros that are used to annotate types which
are to be exported to PHP. This allows you to write Rust-like APIs that can be
used from PHP without fiddling around with zvals.</p>
<ul>
<li><a href="macros/./module.html"><code>php_module</code></a> - Defines the function used by PHP to retrieve your extension.</li>
<li><a href="macros/./module_startup.html"><code>php_startup</code></a> - Defines the extension startup function used by PHP to
initialize your extension.</li>
<li><a href="macros/./function.html"><code>php_function</code></a> - Used to export a Rust function to PHP.</li>
<li><a href="macros/./structs.html"><code>php_class</code></a> - Used to export a Rust struct or enum as a PHP class.</li>
<li><a href="macros/./impl.html"><code>php_impl</code></a> - Used to export a Rust <code>impl</code> block to PHP, including all
methods and constants.</li>
<li><a href="macros/./constant.html"><code>php_const</code></a> - Used to export a Rust constant to PHP as a global constant.</li>
</ul>
<p>These macros do abuse the fact that (at the moment) proc macro expansion <em>seems</em>
to happen orderly, on one single thread. It has been stated many times that this
order is undefined behaviour (<a href="https://github.com/rust-lang/reference/issues/578">see here</a>), so these macros <em>could</em> break at any
time with a <code>rustc</code> update (let's just keep our fingers crossed).</p>
<p>The macros abuse this fact by storing a global state, which stores information
about all the constants, functions, methods and classes you have registered
throughout your crate. It is then read out of the state in the function tagged
with the <code>#[php_module]</code> attribute. This is why this function <strong>must</strong> be the
last function in your crate.</p>
<p>In the case the ordering does change (or we find out that it already was not in
order), the most likely solution will be having to register your PHP exports
manually inside the <code>#[php_module]</code> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_module"><a class="header" href="#php_module"><code>#[php_module]</code></a></h1>
<p>The module macro is used to annotate the <code>get_module</code> function, which is used by
the PHP interpreter to retrieve information about your extension, including the
name, version, functions and extra initialization functions. Regardless if you
use this macro, your extension requires a <code>extern "C" fn get_module()</code> so that
PHP can get this information.</p>
<p>Using the macro, any functions annotated with the <code>php_function</code> macro will be
automatically registered with the extension in this function. If you have
defined any constants or classes with their corresponding macros, a 'module
startup' function will also be generated if it has not already been defined.</p>
<p>Automatically registering these functions requires you to define the module
function <strong>after</strong> all other functions have been registered, as macros are
expanded in-order, therefore this macro will not know that other functions have
been used after.</p>
<p>The function is renamed to <code>get_module</code> if you have used another name. The
function is passed an instance of <code>ModuleBuilder</code> which allows you to register
the following (if required):</p>
<ul>
<li>Extension and request startup and shutdown functions.
<ul>
<li>Read more about the PHP extension lifecycle
<a href="https://www.phpinternalsbook.com/php7/extensions_design/php_lifecycle.html">here</a>.</li>
</ul>
</li>
<li>PHP extension information function
<ul>
<li>Used by the <code>phpinfo()</code> function to get information about your extension.</li>
</ul>
</li>
<li>Functions not automatically registered</li>
</ul>
<p>Classes and constants are not registered in the <code>get_module</code> function. These are
registered inside the extension startup function.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code class="language-rust ignore"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span><span class="boring">use ext_php_rs::{info_table_start, info_table_row, info_table_end};
</span><span class="boring">use ext_php_rs::php::module::ModuleEntry;
</span>/// Used by the `phpinfo()` function and when you run `php -i`.
/// This will probably be simplified with another macro eventually!
pub extern "C" fn php_module_info(_module: *mut ModuleEntry) {
    info_table_start!();
    info_table_row!("my extension", "enabled");
    info_table_end!();
}

#[php_module]
pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
    module.info_function(php_module_info)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_startup"><a class="header" href="#php_startup"><code>#[php_startup]</code></a></h1>
<p>Used to define the PHP extension startup function. This function is used to
register extension classes and constants with the PHP interpreter.</p>
<p>This function is automatically generated if you have registered classes or
constants and have not already used this macro. If you do use this macro, it
will be automatically registered in the <code>get_module</code> function when you use the
<code>#[php_module]</code> attribute.</p>
<p>Most of the time you won't need to use this macro as the startup function will
be automatically generated when required (if not already defined).</p>
<p>Read more about what the module startup function is used for
<a href="https://www.phpinternalsbook.com/php7/extensions_design/php_lifecycle.html#module-initialization-minit">here.</a></p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_startup]
pub fn startup_function() {

}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_function"><a class="header" href="#php_function"><code>#[php_function]</code></a></h1>
<p>Used to annotate functions which should be exported to PHP. Note that this
should not be used on class methods - see the <code>#[php_impl]</code> macro for that.</p>
<p>See the <a href="macros/../types/index.html">list of types</a> that are valid as parameter and
return types.</p>
<h2 id="optional-parameters"><a class="header" href="#optional-parameters">Optional parameters</a></h2>
<p>Optional parameters can be used by setting the Rust parameter type to a variant
of <code>Option&lt;T&gt;</code>. The macro will then figure out which parameters are optional by
using the last consecutive arguments that are a variant of <code>Option&lt;T&gt;</code> or have a
default value.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function]
pub fn greet(name: String, age: Option&lt;i32&gt;) -&gt; String {
    let mut greeting = format!("Hello, {}!", name);

    if let Some(age) = age {
        greeting += &amp;format!(" You are {} years old.", age);
    }

    greeting
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Default parameter values can also be set for optional parameters. This is done
through the <code>defaults</code> attribute option. When an optional parameter has a
default, it does not need to be a variant of <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_function(defaults(offset = 0))]
pub fn rusty_strpos(haystack: &amp;str, needle: &amp;str, offset: i64) -&gt; Option&lt;usize&gt; {
    let haystack: String = haystack.chars().skip(offset as usize).collect();
    haystack.find(needle)
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Note that if there is a non-optional argument after an argument that is a
variant of <code>Option&lt;T&gt;</code>, the <code>Option&lt;T&gt;</code> argument will be deemed a nullable
argument rather than an optional argument.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>/// `age` will be deemed required and nullable rather than optional.
#[php_function]
pub fn greet(name: String, age: Option&lt;i32&gt;, description: String) -&gt; String {
    let mut greeting = format!("Hello, {}!", name);

    if let Some(age) = age {
        greeting += &amp;format!(" You are {} years old.", age);
    }

    greeting += &amp;format!(" {}.", description);
    greeting
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>You can also specify the optional arguments if you want to have nullable
arguments before optional arguments. This is done through an attribute
parameter:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>/// `age` will be deemed required and nullable rather than optional,
/// while description will be optional.
#[php_function(optional = "description")]
pub fn greet(name: String, age: Option&lt;i32&gt;, description: Option&lt;String&gt;) -&gt; String {
    let mut greeting = format!("Hello, {}!", name);

    if let Some(age) = age {
        greeting += &amp;format!(" You are {} years old.", age);
    }

    if let Some(description) = description {
        greeting += &amp;format!(" {}.", description);
    }

    greeting
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="variadic-functions"><a class="header" href="#variadic-functions">Variadic Functions</a></h2>
<p>Variadic functions can be implemented by specifying the last argument in the Rust
function to the type <code>&amp;[&amp;Zval]</code>. This is the equivelant of a PHP function using
the <code>...$args</code> syntax.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span><span class="boring">use ext_php_rs::types::Zval;
</span>/// This can be called from PHP as `add(1, 2, 3, 4, 5)`
#[php_function]
pub fn add(number: u32, numbers:&amp;[&amp;Zval]) -&gt; u32 {
    // numbers is a slice of 4 Zvals all of type long
    number
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="returning-resultt-e"><a class="header" href="#returning-resultt-e">Returning <code>Result&lt;T, E&gt;</code></a></h2>
<p>You can also return a <code>Result</code> from the function. The error variant will be
translated into an exception and thrown. See the section on
<a href="macros/../exceptions.html">exceptions</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>Structs can be exported to PHP as classes with the <code>#[php_class]</code> attribute
macro. This attribute derives the <code>RegisteredClass</code> trait on your struct, as
well as registering the class to be registered with the <code>#[php_module]</code> macro.</p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>The attribute takes some options to modify the output of the class:</p>
<ul>
<li><code>name</code> - Changes the name of the class when exported to PHP. The Rust struct
name is kept the same. If no name is given, the name of the struct is used.
Useful for namespacing classes.</li>
</ul>
<p>There are also additional macros that modify the class. These macros <strong>must</strong> be
placed underneath the <code>#[php_class]</code> attribute.</p>
<ul>
<li><code>#[extends(ce)]</code> - Sets the parent class of the class. Can only be used once.
<code>ce</code> must be a valid Rust expression when it is called inside the
<code>#[php_module]</code> function.</li>
<li><code>#[implements(ce)]</code> - Implements the given interface on the class. Can be used
multiple times. <code>ce</code> must be a valid Rust expression when it is called inside
the <code>#[php_module]</code> function.</li>
</ul>
<p>You may also use the <code>#[prop]</code> attribute on a struct field to use the field as a
PHP property. By default, the field will be accessible from PHP publicly with
the same name as the field. Property types must implement <code>IntoZval</code> and
<code>FromZval</code>.</p>
<p>You can rename the property with options:</p>
<ul>
<li><code>rename</code> - Allows you to rename the property, e.g.
<code>#[prop(rename = "new_name")]</code></li>
</ul>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<h3 id="no-lifetime-parameters"><a class="header" href="#no-lifetime-parameters">No lifetime parameters</a></h3>
<p>Rust lifetimes are used by the Rust compiler to reason about a program's memory safety.
They are a compile-time only concept;
there is no way to access Rust lifetimes at runtime from a dynamic language like PHP.</p>
<p>As soon as Rust data is exposed to PHP,
there is no guarantee which the Rust compiler can make on how long the data will live.
PHP is a reference-counted language and those references can be held
for an arbitrarily long time, which is untraceable by the Rust compiler.
The only possible way to express this correctly is to require that any <code>#[php_class]</code>
does not borrow data for any lifetime shorter than the <code>'static</code> lifetime,
i.e. the <code>#[php_class]</code> cannot have any lifetime parameters.</p>
<p>When you need to share ownership of data between PHP and Rust,
instead of using borrowed references with lifetimes, consider using
reference-counted smart pointers such as <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>.</p>
<h3 id="no-generic-parameters"><a class="header" href="#no-generic-parameters">No generic parameters</a></h3>
<p>A Rust struct <code>Foo&lt;T&gt;</code> with a generic parameter <code>T</code> generates new compiled implementations
each time it is used with a different concrete type for <code>T</code>.
These new implementations are generated by the compiler at each usage site.
This is incompatible with wrapping <code>Foo</code> in PHP,
where there needs to be a single compiled implementation of <code>Foo</code> which is integrated with the PHP interpreter.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>This example creates a PHP class <code>Human</code>, adding a PHP property <code>address</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_class]
pub struct Human {
    name: String,
    age: i32,
    #[prop]
    address: String,
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Create a custom exception <code>RedisException</code>, which extends <code>Exception</code>, and put
it in the <code>Redis\Exception</code> namespace:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;
use ext_php_rs::{exception::PhpException, zend::ce};

#[php_class(name = "Redis\\Exception\\RedisException")]
#[extends(ce::exception())]
#[derive(Default)]
pub struct RedisException;

// Throw our newly created exception
#[php_function]
pub fn throw_exception() -&gt; PhpResult&lt;i32&gt; {
    Err(PhpException::from_class::&lt;RedisException&gt;("Not good!".into()))
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="implementing-an-interface"><a class="header" href="#implementing-an-interface">Implementing an Interface</a></h2>
<p>To implement an interface, use <code>#[implements(ce)]</code> where <code>ce</code> is an expression returning a <code>ClassEntry</code>.
The following example implements <a href="https://www.php.net/manual/en/class.arrayaccess.php"><code>ArrayAccess</code></a>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;
use ext_php_rs::{exception::PhpResult, types::Zval, zend::ce};

#[php_class]
#[implements(ce::arrayaccess())]
#[derive(Default)]
pub struct EvenNumbersArray;

/// Returns `true` if the array offset is an even number.
/// Usage:
/// ```php
/// $arr = new EvenNumbersArray();
/// var_dump($arr[0]); // true
/// var_dump($arr[1]); // false
/// var_dump($arr[2]); // true
/// var_dump($arr[3]); // false
/// var_dump($arr[4]); // true
/// var_dump($arr[5] = true); // Fatal error:  Uncaught Exception: Setting values is not supported
/// ```
#[php_impl]
impl EvenNumbersArray {
    pub fn __construct() -&gt; EvenNumbersArray {
        EvenNumbersArray {}
    }
    // We need to use `Zval` because ArrayAccess needs $offset to be a `mixed`
    pub fn offset_exists(&amp;self, offset: &amp;'_ Zval) -&gt; bool {
        offset.is_long()
    }
    pub fn offset_get(&amp;self, offset: &amp;'_ Zval) -&gt; PhpResult&lt;bool&gt; {
        let integer_offset = offset.long().ok_or("Expected integer offset")?;
        Ok(integer_offset % 2 == 0)
    }
    pub fn offset_set(&amp;mut self, _offset: &amp;'_ Zval, _value: &amp;'_ Zval) -&gt; PhpResult {
        Err("Setting values is not supported".into())
    }
    pub fn offset_unset(&amp;mut self, _offset: &amp;'_ Zval) -&gt; PhpResult {
        Err("Setting values is not supported".into())
    }
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_impl"><a class="header" href="#php_impl"><code>#[php_impl]</code></a></h1>
<p>You can export an entire <code>impl</code> block to PHP. This exports all methods as well
as constants to PHP on the class that it is implemented on. This requires the
<code>#[php_class]</code> macro to already be used on the underlying struct. Trait
implementations cannot be exported to PHP.</p>
<p>If you do not want a function exported to PHP, you should place it in a separate
<code>impl</code> block.</p>
<p>If you want to use async Rust, use <code>#[php_async_impl]</code>, instead: see <a href="macros/./async_impl.html">here »</a> for more info.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods basically follow the same rules as functions, so read about the
[<code>php_function</code>] macro first. The primary difference between functions and
methods is they are bounded by their class object.</p>
<p>Class methods can take a <code>&amp;self</code> or <code>&amp;mut self</code> parameter. They cannot take a
consuming <code>self</code> parameter. Static methods can omit this <code>self</code> parameter.</p>
<p>To access the underlying Zend object, you can take a reference to a
<code>ZendClassObject&lt;T&gt;</code> in place of the self parameter, where the parameter is
annotated with the <code>#[this]</code> attribute. This can also be used to return a
reference to <code>$this</code>.</p>
<p>By default, all methods are renamed in PHP to the camel-case variant of the Rust
method name. This can be changed on the <code>#[php_impl]</code> attribute, by passing one
of the following as the <code>rename_methods</code> option:</p>
<ul>
<li><code>"none"</code> - does not rename the methods.</li>
<li><code>"camelCase"</code> - renames all methods to camel case (default).</li>
<li><code>"snake_case"</code> - renames all methods to snake case.</li>
</ul>
<p>For example, to disable renaming, change the <code>#[php_impl]</code> attribute to
<code>#[php_impl(rename_methods = "none")]</code>.</p>
<p>The rest of the options are passed as separate attributes:</p>
<ul>
<li><code>#[defaults(i = 5, b = "hello")]</code> - Sets the default value for parameter(s).</li>
<li><code>#[optional(i)]</code> - Sets the first optional parameter. Note that this also sets
the remaining parameters as optional, so all optional parameters must be a
variant of <code>Option&lt;T&gt;</code>.</li>
<li><code>#[public]</code>, <code>#[protected]</code> and <code>#[private]</code> - Sets the visibility of the
method.</li>
<li><code>#[rename("method_name")]</code> - Renames the PHP method to a different identifier,
without renaming the Rust method name.</li>
</ul>
<p>The <code>#[defaults]</code> and <code>#[optional]</code> attributes operate the same as the
equivalent function attribute parameters.</p>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<p>By default, if a class does not have a constructor, it is not constructable from
PHP. It can only be returned from a Rust function to PHP.</p>
<p>Constructors are Rust methods which can take any amount of parameters and
returns either <code>Self</code> or <code>Result&lt;Self, E&gt;</code>, where <code>E: Into&lt;PhpException&gt;</code>. When
the error variant of <code>Result</code> is encountered, it is thrown as an exception and
the class is not constructed.</p>
<p>Constructors are designated by either naming the method <code>__construct</code> or by
annotating a method with the <code>#[constructor]</code> attribute. Note that when using
the attribute, the function is not exported to PHP like a regular method.</p>
<p>Constructors cannot use the visibility or rename attributes listed above.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Constants are defined as regular Rust <code>impl</code> constants. Any type that implements
<code>IntoZval</code> can be used as a constant. Constant visibility is not supported at
the moment, and therefore no attributes are valid on constants.</p>
<h2 id="property-getters-and-setters"><a class="header" href="#property-getters-and-setters">Property getters and setters</a></h2>
<p>You can add properties to classes which use Rust functions as getters and/or
setters. This is done with the <code>#[getter]</code> and <code>#[setter]</code> attributes. By
default, the <code>get_</code> or <code>set_</code> prefix is trimmed from the start of the function
name, and the remainder is used as the property name.</p>
<p>If you want to use a different name for the property, you can pass a <code>rename</code>
option to the attribute which will change the property name.</p>
<p>Properties do not necessarily have to have both a getter and a setter, if the
property is immutable the setter can be omitted, and vice versa for getters.</p>
<p>The <code>#[getter]</code> and <code>#[setter]</code> attributes are mutually exclusive on methods.
Properties cannot have multiple getters or setters, and the property name cannot
conflict with field properties defined on the struct.</p>
<p>As the same as field properties, method property types must implement both
<code>IntoZval</code> and <code>FromZval</code>.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>Continuing on from our <code>Human</code> example in the structs section, we will define a
constructor, as well as getters for the properties. We will also define a
constant for the maximum age of a <code>Human</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::{prelude::*, types::ZendClassObject};
</span><span class="boring">#[php_class]
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">pub struct Human {
</span><span class="boring">    name: String,
</span><span class="boring">    age: i32,
</span><span class="boring">    #[prop]
</span><span class="boring">    address: String,
</span><span class="boring">}
</span>#[php_impl]
impl Human {
    const MAX_AGE: i32 = 100;

    // No `#[constructor]` attribute required here - the name is `__construct`.
    pub fn __construct(name: String, age: i32) -&gt; Self {
        Self { name, age, address: String::new() }
    }

    #[getter]
    pub fn get_name(&amp;self) -&gt; String {
        self.name.to_string()
    }

    #[setter]
    pub fn set_name(&amp;mut self, name: String) {
        self.name = name;
    }

    #[getter]
    pub fn get_age(&amp;self) -&gt; i32 {
        self.age
    }

    pub fn introduce(&amp;self) {
        println!("My name is {} and I am {} years old. I live at {}.", self.name, self.age, self.address);
    }

    pub fn get_raw_obj(#[this] this: &amp;mut ZendClassObject&lt;Human&gt;) {
        dbg!(this);   
    }

    pub fn get_max_age() -&gt; i32 {
        Self::MAX_AGE
    }
}
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
</span><span class="boring">    module
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Using our newly created class in PHP:</p>
<pre><code class="language-php">&lt;?php

$me = new Human('David', 20);

$me-&gt;introduce(); // My name is David and I am 20 years old.
var_dump(Human::get_max_age()); // int(100)
var_dump(Human::MAX_AGE); // int(100)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_async_impl-1"><a class="header" href="#php_async_impl-1"><code>#[php_async_impl]</code></a></h1>
<p>Using <code>#[php_async_impl]</code> instead of <code>#[php_impl]</code> allows us to expose any async Rust library to PHP, using <a href="https://www.php.net/manual/en/language.fibers.php">PHP fibers</a>, <a href="https://github.com/danog/php-tokio">php-tokio</a> and the <a href="https://revolt.run">PHP Revolt event loop</a> under the hood to handle async interoperability.</p>
<p>This allows full compatibility with <a href="https://amphp.org">amphp</a>, <a href="https://github.com/azjezz/psl">PSL</a>, <a href="https://reactphp.org">reactphp</a> and any other async PHP library based on <a href="https://revolt.run">Revolt</a>.</p>
<p>Traits annotated with <code>#[php_async_impl]</code> can freely expose any async function, using <code>await</code> and any async Rust library.</p>
<p>Make sure to also expose the <code>php_tokio::EventLoop::init</code> and <code>php_tokio::EventLoop::wakeup</code> functions to PHP in order to initialize the event loop, as specified in the full example <a href="macros/async_impl.html#async-example">here »</a>.</p>
<p>Also, make sure to invoke <code>EventLoop::shutdown</code> in the request shutdown handler to clean up the tokio event loop before finishing the request.</p>
<h2 id="async-example-1"><a class="header" href="#async-example-1">Async example</a></h2>
<p>In this example, we're exposing an async Rust HTTP client library called <a href="https://docs.rs/reqwest/latest/reqwest/">reqwest</a> to PHP, using <a href="https://www.php.net/manual/en/language.fibers.php">PHP fibers</a>, <a href="https://github.com/danog/php-tokio">php-tokio</a> and the <a href="https://revolt.run">PHP Revolt event loop</a> under the hood to handle async interoperability.</p>
<p>This allows full compatibility with <a href="https://amphp.org">amphp</a>, <a href="https://github.com/azjezz/psl">PSL</a>, <a href="https://reactphp.org">reactphp</a> and any other async PHP library based on <a href="https://revolt.run">Revolt</a>.</p>
<p>Make sure to require <a href="https://github.com/danog/php-tokio">php-tokio</a> as a dependency before proceeding.</p>
<pre><code class="language-rust ignore">use ext_php_rs::prelude::*;
use php_tokio::{php_async_impl, EventLoop};

#[php_class]
struct Client {}

#[php_async_impl]
impl Client {
    pub fn init() -&gt; PhpResult&lt;u64&gt; {
        EventLoop::init()
    }
    pub fn wakeup() -&gt; PhpResult&lt;()&gt; {
        EventLoop::wakeup()
    }
    pub async fn get(url: &amp;str) -&gt; anyhow::Result&lt;String&gt; {
        Ok(reqwest::get(url).await?.text().await?)
    }
}

pub extern "C" fn request_shutdown(_type: i32, _module_number: i32) -&gt; i32 {
    EventLoop::shutdown();
    0
}

#[php_module]
pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder {
    module.request_shutdown_function(request_shutdown)
}</code></pre>
<p>Here's the async PHP code we use to interact with the Rust class we just exposed.</p>
<p>The <code>Client::init</code> method needs to be called only once in order to initialize the Revolt event loop and link it to the Tokio event loop, as shown by the following code.</p>
<p>See <a href="https://amphp.org">here »</a> for more info on async PHP using <a href="https://amphp.org">amphp</a> + <a href="https://revolt.run">revolt</a>.</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);

namespace Reqwest;

use Revolt\EventLoop;

use function Amp\async;
use function Amp\Future\await;

final class Client
{
    private static ?string $id = null;

    public static function init(): void
    {
        if (self::$id !== null) {
            return;
        }

        $f = \fopen("php://fd/".\Client::init(), 'r+');
        \stream_set_blocking($f, false);
        self::$id = EventLoop::onReadable($f, fn () =&gt; \Client::wakeup());
    }

    public static function reference(): void
    {
        EventLoop::reference(self::$id);
    }
    public static function unreference(): void
    {
        EventLoop::unreference(self::$id);
    }

    public static function __callStatic(string $name, array $args): mixed
    {
        return \Client::$name(...$args);
    }
}


Client::init();

function test(int $delay): void
{
    $url = "https://httpbin.org/delay/$delay";
    $t = time();
    echo "Making async reqwest to $url that will return after $delay seconds...".PHP_EOL;
    Client::get($url);
    $t = time() - $t;
    echo "Got response from $url after ~".$t." seconds!".PHP_EOL;
};

$futures = [];
$futures []= async(test(...), 5);
$futures []= async(test(...), 5);
$futures []= async(test(...), 5);

await($futures);
</code></pre>
<p>Result:</p>
<pre><code>Making async reqwest to https://httpbin.org/delay/5 that will return after 5 seconds...
Making async reqwest to https://httpbin.org/delay/5 that will return after 5 seconds...
Making async reqwest to https://httpbin.org/delay/5 that will return after 5 seconds...
Got response from https://httpbin.org/delay/5 after ~5 seconds!
Got response from https://httpbin.org/delay/5 after ~5 seconds!
Got response from https://httpbin.org/delay/5 after ~5 seconds!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php_const"><a class="header" href="#php_const"><code>#[php_const]</code></a></h1>
<p>Exports a Rust constant as a global PHP constant. The constant can be any type
that implements <code>IntoConst</code>.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span>#[php_const]
const TEST_CONSTANT: i32 = 100;

#[php_const]
const ANOTHER_STRING_CONST: &amp;'static str = "Hello world!";
<span class="boring">#[php_module]
</span><span class="boring">pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder { module }
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="php-usage-2"><a class="header" href="#php-usage-2">PHP usage</a></h2>
<pre><code class="language-php">&lt;?php

var_dump(TEST_CONSTANT); // int(100)
var_dump(ANOTHER_STRING_CONST); // string(12) "Hello world!"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zvalconvert"><a class="header" href="#zvalconvert"><code>ZvalConvert</code></a></h1>
<p>The <code>#[derive(ZvalConvert)]</code> macro derives the <code>FromZval</code> and <code>IntoZval</code> traits
on a struct or enum.</p>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>When used on a struct, the <code>FromZendObject</code> and <code>IntoZendObject</code> traits are also
implemented, mapping fields to properties in both directions. All fields on the
struct must implement <code>FromZval</code> as well. Generics are allowed on structs that
use the derive macro, however, the implementation will add a <code>FromZval</code> bound to
all generics types.</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

#[derive(ZvalConvert)]
pub struct ExampleClass&lt;'a&gt; {
    a: i32,
    b: String,
    c: &amp;'a str
}

#[php_function]
pub fn take_object(obj: ExampleClass) {
    dbg!(obj.a, obj.b, obj.c);
}

#[php_function]
pub fn give_object() -&gt; ExampleClass&lt;'static&gt; {
    ExampleClass {
        a: 5,
        b: "String".to_string(),
        c: "Borrowed",
    }
}
<span class="boring">#[php_module] pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder { module }
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Calling from PHP:</p>
<pre><code class="language-php">&lt;?php

$obj = new stdClass;
$obj-&gt;a = 5;
$obj-&gt;b = 'Hello, world!';
$obj-&gt;c = 'another string';

take_object($obj);
var_dump(give_object());
</code></pre>
<p>Another example involving generics:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

// T must implement both `PartialEq&lt;i32&gt;` and `FromZval`.
#[derive(Debug, ZvalConvert)]
pub struct CompareVals&lt;T: PartialEq&lt;i32&gt;&gt; {
    a: T,
    b: T
}

#[php_function]
pub fn take_object(obj: CompareVals&lt;i32&gt;) {
    dbg!(obj);
}
<span class="boring">#[php_module] pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder { module }
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>When used on an enum, the <code>FromZval</code> implementation will treat the enum as a
tagged union with a mixed datatype. This allows you to accept multiple types in
a parameter, for example, a string and an integer.</p>
<p>The enum variants must not have named fields, and each variant must have exactly
one field (the type to extract from the zval). Optionally, the enum may have one
default variant with no data contained, which will be used when the rest of the
variants could not be extracted from the zval.</p>
<p>The ordering of the variants in the enum is important, as the <code>FromZval</code>
implementation will attempt to parse the zval data in order. For example, if you
put a <code>String</code> variant before an integer variant, the integer would be converted
to a string and passed as the string variant.</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<p>Basic example showing the importance of variant ordering and default field:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;

#[derive(Debug, ZvalConvert)]
pub enum UnionExample&lt;'a&gt; {
    Long(u64), // Long
    ProperStr(&amp;'a str), // Actual string - not a converted value
    ParsedStr(String), // Potentially parsed string, i.e. a double
    None // Zval did not contain anything that could be parsed above
}

#[php_function]
pub fn test_union(val: UnionExample) {
    dbg!(val);
}

#[php_function]
pub fn give_union() -&gt; UnionExample&lt;'static&gt; {
    UnionExample::Long(5)
}
<span class="boring">#[php_module] pub fn get_module(module: ModuleBuilder) -&gt; ModuleBuilder { module }
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Use in PHP:</p>
<pre><code class="language-php">test_union(5); // UnionExample::Long(5)
test_union("Hello, world!"); // UnionExample::ProperStr("Hello, world!")
test_union(5.66666); // UnionExample::ParsedStr("5.6666")
test_union(null); // UnionExample::None
var_dump(give_union()); // int(5)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>Exceptions can be thrown from Rust to PHP. The inverse (catching a PHP exception
in Rust) is currently being worked on.</p>
<h2 id="throwing-exceptions"><a class="header" href="#throwing-exceptions">Throwing exceptions</a></h2>
<p><a href="https://docs.rs/ext-php-rs/0.5.0/ext_php_rs/php/exceptions/struct.PhpException.html"><code>PhpException</code></a> is the type that represents an exception. It contains the
message contained in the exception, the type of exception and a status code to
go along with the exception.</p>
<p>You can create a new exception with the <code>new()</code>, <code>default()</code>, or
<code>from_class::&lt;T&gt;()</code> methods. <code>Into&lt;PhpException&gt;</code> is implemented for <code>String</code>
and <code>&amp;str</code>, which creates an exception of the type <code>Exception</code> with a code of 0.
It may be useful to implement <code>Into&lt;PhpException&gt;</code> for your error type.</p>
<p>Calling the <code>throw()</code> method on a <code>PhpException</code> attempts to throw the exception
in PHP. This function can fail if the type of exception is invalid (i.e. does
not implement <code>Exception</code> or <code>Throwable</code>). Upon success, nothing will be
returned.</p>
<p><code>IntoZval</code> is also implemented for <code>Result&lt;T, E&gt;</code>, where <code>T: IntoZval</code> and
<code>E: Into&lt;PhpException&gt;</code>. If the result contains the error variant, the exception
is thrown. This allows you to return a result from a PHP function annotated with
the <code>#[php_function]</code> attribute.</p>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span>use ext_php_rs::prelude::*;
use std::convert::TryInto;

// Trivial example - PHP represents all integers as `u64` on 64-bit systems
// so the `u32` would be converted back to `u64`, but that's okay for an example.
#[php_function]
pub fn something_fallible(n: u64) -&gt; PhpResult&lt;u32&gt; {
    let n: u32 = n.try_into().map_err(|_| "Could not convert into u32")?;
    Ok(n)
}

#[php_module]
pub fn module(module: ModuleBuilder) -&gt; ModuleBuilder {
    module
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ini-settings"><a class="header" href="#ini-settings">INI Settings</a></h1>
<p>Your PHP Extension may want to provide it's own PHP INI settings to configure behaviour. This can be done in the <code>#[php_startup]</code> annotated startup function.</p>
<h2 id="registering-ini-settings"><a class="header" href="#registering-ini-settings">Registering INI Settings</a></h2>
<p>All PHP INI definitions must be registered with PHP to get / set their values via the <code>php.ini</code> file or <code>ini_get() / ini_set()</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span><span class="boring">use ext_php_rs::zend::IniEntryDef;
</span><span class="boring">use ext_php_rs::flags::IniEntryPermission;
</span>
#[php_startup]
pub fn startup_function(ty: i32, module_number: i32) {
    let ini_entries: Vec&lt;IniEntryDef&gt; = vec![
        IniEntryDef::new(
            "my_extension.display_emoji".to_owned(),
            "yes".to_owned(),
            IniEntryPermission::All,
        ),
    ];
    IniEntryDef::register(ini_entries, module_number);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="getting-ini-settings"><a class="header" href="#getting-ini-settings">Getting INI Settings</a></h2>
<p>The INI values are stored as part of the <code>GlobalExecutor</code>, and can be accessed via the <code>ini_values()</code> function. To retrieve the value for a registered INI setting</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![cfg_attr(windows, feature(abi_vectorcall))]
</span><span class="boring">extern crate ext_php_rs;
</span><span class="boring">use ext_php_rs::prelude::*;
</span><span class="boring">use ext_php_rs::zend::ExecutorGlobals;
</span>
#[php_startup]
pub fn startup_function(ty: i32, module_number: i32) {
    // Get all INI values
    let ini_values = ExecutorGlobals::get().ini_values(); // HashMap&lt;String, Option&lt;String&gt;&gt;
    let my_ini_value = ini_values.get("my_extension.display_emoji"); // Option&lt;Option&lt;String&gt;&gt;
}
<span class="boring">fn main() {}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
