//! Represents an object in PHP. Allows for overriding the internal object used by classes,
//! allowing users to store Rust data inside a PHP object.

use std::{mem, ops::Deref};

use crate::{
    bindings::{
        php_rs_zend_object_alloc, std_object_handlers, zend_object, zend_object_handlers,
        zend_object_std_init,
    },
    php::{class::ClassEntry, execution_data::ExecutionData},
};

pub type ZendObject = zend_object;
pub type ZendObjectHandlers = zend_object_handlers;

pub trait ZendObjectOverride {
    extern "C" fn create_object(ce: *mut ClassEntry) -> *mut ZendObject;
}

/// A Zend class object which is allocated when a PHP
/// class object is instantiated. Overrides the default
/// handler when the user provides a type T of the struct
/// they want to override with.
#[repr(C)]
#[derive(Debug)]
pub struct ZendClassObject<T: Default> {
    obj: T,
    std: *mut zend_object,
}

impl<T: Default> ZendClassObject<T> {
    /// Allocates a new object when an instance of the class is created
    /// in the PHP world.
    ///
    /// Internal function. The end user functions are generated by the
    /// [`object_override_handler`] macro which generates a function that
    /// wraps this function to be exported to C.
    ///
    /// # Parameters
    ///
    /// * `ce` - The class entry that was created.
    /// * `handlers` - A reference to the object handlers for the class.
    pub fn new(ce: *mut ClassEntry, handlers: *const ZendObjectHandlers) -> *mut zend_object {
        // SAFETY: We allocate the memory required for the object through the Zend memory manager, therefore
        // we own the memory at this point in time.
        let obj = unsafe {
            let obj = (php_rs_zend_object_alloc(std::mem::size_of::<Self>() as u64, ce)
                as *mut Self)
                .as_mut()
                .unwrap();

            zend_object_std_init(obj.std, ce);
            obj
        };

        obj.obj = T::default();

        // LIMITATION: we can't create static properties on a class object,
        // so we have to recreate the handlers for each object.
        unsafe {
            // let s = std::mem::size_of::<zend_object_handlers>();
            // let handlers = crate::bindings::malloc(s as _) as *mut zend_object_handlers;
            // crate::bindings::memcpy(
            //     handlers as *mut _,
            //     (&crate::bindings::std_object_handlers as *const zend_object_handlers) as *mut _,
            //     s as _,
            // );

            // let offset = std::mem::size_of::<T>();
            // (*handlers).offset = offset as _;
            // (*obj.std).handlers = handlers;
            (*obj.std).handlers = handlers;
        };
        // TODO ojb->std.handlers = &object_handlers
        obj.std
    }

    /// Attempts to retrieve the zend class object container from the
    /// zend object contained in the execution data of a function.
    ///
    /// # Parameters
    ///
    /// * `ex` - The execution data of the function.
    pub fn get(ex: &ExecutionData) -> Option<&'static mut Self> {
        // cast to u8 to work in terms of bytes
        let ptr = ex.This.object()? as *mut u8;
        let offset = std::mem::size_of::<T>();
        unsafe {
            let ptr = ptr.offset(0 - offset as isize);
            (ptr as *mut Self).as_mut()
        }
    }
}

impl<T: Default> Deref for ZendClassObject<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.obj
    }
}

impl ZendObjectHandlers {
    pub fn init() -> *mut ZendObjectHandlers {
        unsafe {
            let s = mem::size_of::<Self>();
            let ptr = libc::malloc(s) as *mut Self;
            libc::memcpy(
                ptr as *mut _,
                (&std_object_handlers as *const Self) as *mut _,
                s,
            );
            println!("");
            ptr
        }
    }
}
